### **1.常用的辅助类**

##### **1）CountDownLatch**

**CountDownLatch** 是 Java 中的一个同步工具类，用于协调多个线程之间的执行顺序。

它通过一个计数器实现，初始值为线程数量。当一个线程完成任务后，计数器减一。

当计数器值为零时，所有等待的线程将被唤醒，继续执行后续任务。



使用场景：

​	CountDownLatch 常用于以下场景：

​	主线程等待子线程完成任务：主线程需要等所有子线程执行完毕之后再继续执行；

​	实现线程的并行启动：多个线程在同一时间开始执行任务，例如模拟并发请求；



主线程等待所有子线程执行完毕的案例：

```
package Day5;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        //总数是6
       CountDownLatch countDownLatch = new CountDownLatch(6);

​        for (int i = 1; i <= 6; i++) {
​            new Thread(() -> {
​                System.out.println(Thread.currentThread().getName() + "==> Go Out");
​                try {
​                    TimeUnit.SECONDS.sleep(3);
​                } catch (InterruptedException e) {
​                    throw new RuntimeException(e);
​                }
​                countDownLatch.countDown(); //每个线程都数量-1
            },String.valueOf(i)).start();
​        }
​        System.out.println("子线程开始启动....");
​        countDownLatch.await(); // 等待计数器归零 然后向下执行
       System.out.println("所有子线程已经执行完毕...");
​    }
}
```



#### 2） cyclicBarrier

**`CyclicBarrier`**：可以让一组线程在某个屏障点相互等待，直到所有线程都到达屏障再一起执行。

**barrierAction**：在最后一个线程到达时，先执行这个动作，然后所有线程继续运行。

**区别于 CountDownLatch**：

​	CountDownLatch` 是一次性的，计数到 0 就结束。

​	CyclicBarrier` 可以复用，屏障释放后可以重新使用。



主线程**创建了一个 `CyclicBarrier`，参与线程数是 **7**。

- 也就是说，需要有 **7 个线程**都调用 `await()`，屏障才会放行。
- 屏障放行时，会先执行传入的 **barrierAction**



```
public class CyclicBarrierDemo {
    public static void main(String[] args) throws InterruptedException {
        *//* *主线程
\*        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,() -> {
            System.*out*.println("召唤神龙");
        });

​        for (int i = 1; i <= 7; i++) {
​            *//* *子线程
\*            int finalI = i;
​            new Thread(() -> {
​                System.*out*.println(Thread.*currentThread*().getName() + "收集了第" + finalI + "颗龙珠");
​                try {
​                    cyclicBarrier.await(); *//* *加法计数 等待
\*                } catch (InterruptedException e) {
​                    e.printStackTrace();
​                } catch (BrokenBarrierException e) {
​                    e.printStackTrace();
​                }
​            }).start();
​        }
​        TimeUnit.*SECONDS*.sleep(5);
​        for (int i = 8; i <= 14; i++) {
​            *//* *子线程
\*            int finalI = i;
​            new Thread(() -> {
​                System.*out*.println(Thread.*currentThread*().getName() + "收集了第" + finalI + "颗龙珠");
​                try {
​                    cyclicBarrier.await(); *//* *加法计数 等待
\*                } catch (InterruptedException e) {
​                    e.printStackTrace();
​                } catch (BrokenBarrierException e) {
​                    e.printStackTrace();
​                }
​            }).start();
​        }
​    }
}
```



#### 3）Semaphore 

信号量(Semaphore)，又被称为信号灯，在多线程环境下用于协调各个线程, 以保证它们能够正确、合理的使用公共资源。信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量。

线程可以通过acquire()方法获取到一个许可，然后对共享资源进行操作。注意如果许可集已分配完了，那么线程将进入等待状态，直到其他线程释放许可才有机会再获取许可，线程释放一个许可通过release()方法完成，"许可"将被归还给Semaphore。



案例：

```
public class SemaphoreDemo {
    public static void main(String[] args) {

​        *//* *线程数量，停车位，限流
\*        Semaphore semaphore = new Semaphore(3);
​        for (int i = 0; i <= 6; i++) {
​            new Thread(() -> {
​                *// acquire()* *得到
\*                try {
​                    semaphore.acquire();
​                    System.*out*.println(Thread.*currentThread*().getName() + "抢到车位");
​                    TimeUnit.*SECONDS*.sleep(2);
​                    System.*out*.println(Thread.*currentThread*().getName() + "离开车位");
​                }catch (Exception e) {
​                    e.printStackTrace();
​                }finally {
​                    semaphore.release(); *// release()* *释放
\*                }
​            }).start();
​        }
​    }
}
```



原理：

**semaphore.acquire()获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！**

**semaphore.release()释放，会将当前的信号量释放+1，然后唤醒等待的线程！**

作用： 多个共享资源互斥的使用！ 并发限流，控制最大的线程数！



## 读写锁：

错误示例：

```
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();
        int num = 6;
        for (int i = 1; i <= num; i++) {
            int finalI = i;
            new Thread(() -> {

                myCache.write(String.valueOf(finalI), String.valueOf(finalI));

            },String.valueOf(i)).start();
        }

        for (int i = 1; i <= num; i++) {
            int finalI = i;
            new Thread(() -> {

                myCache.read(String.valueOf(finalI));

            },String.valueOf(i)).start();
        }
    }
}

/**
 *  方法未加锁，导致写的时候被插队
 */
class MyCache {
    private volatile Map<String, String> map = new HashMap<>();
	// 未加写锁
    public void write(String key, String value) {
        System.out.println(Thread.currentThread().getName() + "线程开始写入");
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + "线程写入ok");
    }
	
	//未加读锁
    public void read(String key) {
        System.out.println(Thread.currentThread().getName() + "线程开始读取");
        map.get(key);
        System.out.println(Thread.currentThread().getName() + "线程写读取ok");
    }
}


```



正确示例：

```
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache2 myCache = new MyCache2();
        int num = 6;
        for (int i = 1; i <= num; i++) {
            int finalI = i;
            new Thread(() -> {

                myCache.write(String.valueOf(finalI), String.valueOf(finalI));

            },String.valueOf(i)).start();
        }

        for (int i = 1; i <= num; i++) {
            int finalI = i;
            new Thread(() -> {

                myCache.read(String.valueOf(finalI));

            },String.valueOf(i)).start();
        }
    }

}
class MyCache2 {
    private volatile Map<String, String> map = new HashMap<>();
    private ReadWriteLock lock = new ReentrantReadWriteLock();

    public void write(String key, String value) {
        lock.writeLock().lock(); // 写锁
        try {
            System.out.println(Thread.currentThread().getName() + "线程开始写入");
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "线程写入ok");

        }finally {
            lock.writeLock().unlock(); // 释放写锁
        }
    }

    public void read(String key) {
        lock.readLock().lock(); // 读锁
        try {
            System.out.println(Thread.currentThread().getName() + "线程开始读取");
            map.get(key);
            System.out.println(Thread.currentThread().getName() + "线程写读取ok");
        }finally {
            lock.readLock().unlock(); // 释放读锁
        }
    }
}
```

加了WriteLock，一次只允许一个线程修改共享变量；

使用readlock允许同时多个线程访问共享变量；

readwriteLock维护一段关联的locks，一个用于只读操作，一个用于只写操作，

read lock可以由多个阅读器线程同时进行，只要没有作者，write lock是独家的；



## 3. 阻塞队列

![img](https://i-blog.csdnimg.cn/blog_migrate/82aa2f3cb2a37409f817d8e8dad94459.png)



**1）BlockQueue**

是Collection的一个子类

**什么情况下会使用阻塞队列：多线程并发处理、线程池**

![img](https://i-blog.csdnimg.cn/blog_migrate/1752930ed6d3e27f9e7185f9dba1487e.png)



BlockingQueue的四组API：

![image-20250903134320443](C:\Users\22932\AppData\Roaming\Typora\typora-user-images\image-20250903134320443.png)





同步队列：

同步队列 没有容量，也可以视为容量为1的队列；

进去一个元素，必须等待取出来之后，才能再往里面放入一个元素；

put方法 和 take方法；

Synchronized 和 其他的BlockingQueue 不一样 它不存储元素；

put了一个元素，就必须从里面先take出来，否则不能再put进去值！

并且SynchronousQueue 的take是使用了lock锁保证线程安全的。



#### 4. 线程池

线程池的好处：

​	1.避免线程的创建和销毁，减少资源的消耗；

​	2.提高响应的速度；

​	3.方便管理；

线程复用、可以控制最大并发数、管理线程；



**2）线程池：三大方法**
ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程
ExecutorService threadPool2 = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小
ExecutorService threadPool3 = Executors.newCachedThreadPool(); //可伸缩的



创建线程池：

```
public class ThreadPoolDemo {
    public static void main(String[] args) {

        ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程
        ExecutorService threadPool2 = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小
        ExecutorService threadPool3 = Executors.newCachedThreadPool(); //可伸缩的

        //线程池用完必须要关闭线程池
        try {

            for (int i = 1; i <=100 ; i++) {
                //通过线程池创建线程
                threadPool3.execute(()->{
                    System.out.println(Thread.currentThread().getName()+ " ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
```

##### 3）线程池七大参数：

```
public ThreadPoolExecutor(int corePoolSize,  //核心线程池大小
                          int maximumPoolSize, //最大的线程池大小
                          long keepAliveTime,  //超时了没有人调用就会释放
                          TimeUnit unit, //超时单位
                          BlockingQueue<Runnable> workQueue, //阻塞队列
                          ThreadFactory threadFactory, //线程工厂 创建线程的 一般不用动
                          RejectedExecutionHandler handler //拒绝策略
                         ) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

![img](https://i-blog.csdnimg.cn/blog_migrate/942cca6a0ef21326a30ac95a7f872ca9.png)



#### 4）拒绝策略

1. new ThreadPoolExecutor.AbortPolicy()： //该拒绝策略为：银行满了，还有人进来，不处理这个人的，并抛出异常

超出最大承载，就会抛出异常：队列容量大小+maxPoolSize

2. new ThreadPoolExecutor.CallerRunsPolicy()： //该拒绝策略为：哪来的去哪里 main线程进行处理

3. new ThreadPoolExecutor.DiscardPolicy(): //该拒绝策略为：队列满了,丢掉异常，不会抛出异常。

4. new ThreadPoolExecutor.DiscardOldestPolicy()： //该拒绝策略为：队列满了，尝试去和最早的进程竞争，不会抛出异常

   

#### 5）如何设置线程池的大小

**（1）、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSize的大小**

```
// 获取cpu 的核数
        int max = Runtime.getRuntime().availableProcessors();
        ExecutorService service =new ThreadPoolExecutor(
                2,
                max,
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );

```





**（2）、I/O密集型：**

在程序中有15个大型任务，io十分占用资源；I/O密集型就是判断我们程序中十分耗I/O的线程数量，大约是最大I/O数的一倍到两倍之间。



#### 5.四大函数式接口

1）Function 函数型接口

![img](https://i-blog.csdnimg.cn/blog_migrate/fde53f33a9e4909aaf6b129ccab5846a.png)

```
public class FunctionDemo {
    public static void main(String[] args) {
        Function<String, String> function = (str) -> {return str;};
        System.out.println(function.apply("aaaaaaaaaa"));
    }
}
```



2）predicate 函数型接口

![image-20200812144545558](https://i-blog.csdnimg.cn/blog_migrate/e658ace0f5d5e3913dbac600e607819c.png)

```
public class PredicateDemo {
    public static void main(String[] args) {
        Predicate<String> predicate = new Predicate<String>() {
            @Override
            public boolean test(String s) {
                return s.equals("hello");
            }
        };

        System.out.println(predicate.test("hello"));
    }
}
```

3）supplier 函数型接口

![img](https://i-blog.csdnimg.cn/blog_migrate/c663f32a07a8f0dde688adb3f8850abc.png)

```
public class SupplierDemo {
    public static void main(String[] args) {
        Supplier<String> supplier = () -> "hello world";
        System.out.println(supplier.get());
    }
}
```



4）consumer函数型接口

![image-20200812144803229](https://i-blog.csdnimg.cn/blog_migrate/c5641402010af463e285685614c2a92a.png)

```
import java.util.function.Consumer;

public class ConsumerDemo {
    public static void main(String[] args) {
        Consumer<String> consumer=(str)->{
            System.out.println(str);
        };
        consumer.accept("hello world");
    }
}
```

