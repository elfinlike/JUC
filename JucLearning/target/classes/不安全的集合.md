## **集合不安全：**

**1. List不安全：**

循环次数较少可能不会发现出问题：

```
public class ListTest {
    public static void main(String[] args) {
​        List<Object> arrayList = new ArrayList<>();
​        for(int i=1;i<=100;i++){
​            new Thread(()->{
​                arrayList.add(UUID.*randomUUID*().toString().substring(0,5));
​                System.*out*.println(arrayList);
​            },String.*valueOf*(i)).start();
​        }
​    }

}
```

会导致

```
java.util.ConcurrentModificationException
```

 并发修改异常，或者是创建出的list是有并发问题的；

**例如：**

```
java.util.ConcurrentModificationException
	at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1013)
	at java.base/java.util.ArrayList$Itr.next(ArrayList.java:967)
	at java.base/java.util.AbstractCollection.toString(AbstractCollection.java:456)
	at java.base/java.lang.String.valueOf(String.java:4220)
	at java.base/java.io.PrintStream.println(PrintStream.java:1047)
	at Day4.ListTest.lambda$main$0(ListTest.java:15)
	at java.base/java.lang.Thread.run(Thread.java:840)
```





**使用CopyOnWriteArrayList：**

```
public class CopyOnWriteArrayListTest {
    public static void main(String[] args) {
        */**
\*         *** *解决方案
\*         ** 1. List**<String>* *list = new Vector<>();
\*         ** 2. List**<String>* *list = Collections.synchronizedList(new ArrayList<>());
\*         ** 3. List**<String>* *list = new CopyOnWriteArrayList<>();
\*         **/        
		 List<String> list = new CopyOnWriteArrayList<>();

​        for (int i = 1; i <=100; i++) {
​            new Thread(() -> {
​                list.add(UUID.*randomUUID*().toString().substring(0,5));
​                System.*out*.println(list);
​            },String.*valueOf*(i)).start();
​        }
​        }
​    }
```



使用**CopyOnWriteArrayList**的原因：

​	

```
写入时复制：

​		如果有多个调用者同时要求相同的资源，他们会共同获得相同的指针，指向相同的资源；

​		直到某个调用者试图修改资源内容时，系统才会真正复制一份专用副本给该调用者，而其它调用者所见的

​		最初的资源依旧是不变的。这个过程对于其他调用者都是透明的；



​	读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，

​    因为写的时候不会锁住旧的CopyOnWriteArrayList。 
```



**CopyOnWriteArrayList比Vector厉害在哪里？**

Vector的底层是使用synchronized关键字来实现的，效率相对低下；

![img](https://i-blog.csdnimg.cn/blog_migrate/0416989100c4f7a96c92e57d55fc7847.png)

CopyOnWriteArrayList的底层则是使用的Lock锁，效率相对更加高效；



![img](https://i-blog.csdnimg.cn/blog_migrate/e0f9043074bdd316f04392ef6f7695a9.png)





**2. Set不安全**

**Set和List同理可得:** 多线程情况下，普通的Set集合是线程不安全的；

使用Collections工具类的Synchronized包装的set类；

使用CopyOnWriteArraySet写入复制的JUC解决方案；



```
public class SetTest {
    public static void main(String[] args) {
        /**
         * 1. Set<String> set = Collections.synchronizedSet(new HashSet<>());
         * 2. Set<String> set = new CopyOnWriteArraySet<>();
         */
//        Set<String> set = new HashSet<>();
        Set<String> set = new CopyOnWriteArraySet<>();

        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                set.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(set);
            },String.valueOf(i)).start();
        }
    }

}
```



**3.Map不安全，HashMap是线程不安全的，对于线程安全的Map，使用ConcurrentHashMap；**

​	在jdk1.7 使用的segment的分段锁（Lock Striping），将整个哈希表分为几个段，每个段都可以独立锁定，读取操作不需要操作	

，写入操作仅锁定相应的段，减少了锁冲突的几率，从而提高了并发的性能；



在jdk1.8 废弃了segment的分段锁，采用CAS和synchronized关键字来保证并发安全性；

整个容器只分为一个segment，即table数组；









